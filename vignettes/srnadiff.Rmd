---
title: "The sRNADiff package"
author: "Matthias Zytnicki"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

sRNADiff aims at finding differentially expressed short RNAs with or without
annotation.  To do so, sRNADiff uses up to 4 different strategies:

- annotation-based,
- naive,
- HMM,
- clustering.

## Standard workflow

    annotation  <- readMiRBasePreAnnotation("mirbase.gff")
    bamFiles    <- c("wt1.bam", "wt2.bam", "wt3.bam", "ko1.bam", "ko2.bam", "ko3.bam")
    replicates  <- c("wt1", "wt2", "wt3", "ko1", "ko2", "ko3")
    conditions  <- factor(c("wt", "wt", "wt", "ko", "ko", "ko"))
    exp         <- sRNADiffExp(annotation, bamFiles, replicates, conditions)
    diffRegions <- runAll(exp)
    
    
## Example

Raw data have been downloaded from the GEO data set
[GSE62830](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE62830),
provided in
[Viollet *et al.*, 2015](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0126439).
Adapters were removed with
[fastx_clipper](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html)
and mapped with
[bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml)
on the human genome version GRCh38.

This example provides this data, restricted to a small locus on chr14.
It uses the whole genome annotation (with coding genes, etc.)
and extracts miRNAs.

    dir         <- system.file("extdata", package="srnadiff", mustWork = TRUE)
    data        <- read.csv(file.path(dir, "data.csv"))
    gtfFile     <- file.path(dir, "Homo_sapiens.GRCh38.76.gtf")
    annotation  <- readWholeGenomeAnnotation(gtfFile)
    bamFiles    <- file.path(dir, data$FileName)
    replicates  <- data$SampleName
    conditions  <- factor(data$Condition)
    exp         <- sRNADiffExp(annotation, bamFiles, replicates, conditions)
    diffRegions <- runAll(exp)

For your conveniance, the sample can be loaded with an only command `exp <- sRNADiffExample()`, so the script boils down to:

    exp         <- sRNADiffExample()
    diffRegions <- runAll(exp)


## Rationale and scope of the package

There is no real method for finding differentially expressed short RNAs.  The
most used method focusses on miRNAs, and only uses a standard RNA-Seq pipe-line
on these genes.

However, annotated tRF, siRNAs, piRNA, etc. are thus out of the scope of these
analyses.  Several ad hoc method have been used, and this package implements a
unifying method, finding differentially expressed genes or regions of any kind.


## Explanation of the different strategies

Each strategy segments the genome its own way and finds potential differentially
expressed regions.
Every strategy makes assumption of the profiles of the differentially expressed
regions.
These assumptions differ between strategies, and thus it is useful to combined
them.

### Annotation

This is the standard pipe-line, and the method simply provides the list of miRNA
genes extracted from the given GTF file.

If you do not provide a GTF file, this step is skipped.

Unfortunately, there is no clear standard for an annotation format.
We provide here four ways to parse the annotation file.


#### Whole genome file annotation

This GTF file can be found in the central repositories (NCBI, Ensembl) and
contains all the annotation found in an organism (coding genes, tranposable
element, etc.).
The following function reads the annotation file and extracts the miRNAs.

    annotation <- readWholeGenomeAnnotation(filename)


#### miRBase annotation

miRBase is the central repository for miRNAs.
The following function parses a GFF3 miRBase file, and extracts the precursor
miRNAs.

    annotation <- readMiRBasePreAnnotation(filename)

As a result, the reads will be counted per pre-miRNA, and the 5' and 3' arms,
the miRNA and the miRNA* will be merged in the same feature.
If you want to separate the two, use:

    annotation <- readMiRBaseMatureAnnotation(filename)


#### Other format

When the previous functions do not work, you can use your own parser with:

    annotation <- readAnnotation(filename, source, feature, name)

The `source` parameter keeps all the lines such that the second field matches
the given parameter (e.g. `miRNA`).
The `feature` parameter keeps all the lines such that the third field matches
the given parameter (e.g. `gene`).
The name of the feature will be given by the tag `name` (e.g. `gene_name`).
`source`, `feature` and `name` can be `NULL`.
In this case, no selection is performed on `source` or `feature`.
If `name` is null, then a systematic name is given (`annotation_N`).


### Naive

This strategy is the simplest, most commonly used, to find transcription units.  It proceeds in two steps.

The first step merges all the BAM files.  Regions with a minimum number coverage (summing all the reads in all input BAM files) are kept.

The second steps merges regions that are within a given distance (also provided by the user).  The default distance can be change using this function:

    exp <- setMergeDistance(exp, numeric)

This method is efficient when a gene is differentially expressed on the whole transcript.


### HMM

This strategy first computes the coverage of every input BAM file of every nucleotide of the genome.
If two genome nucleotides have exactly the same coverage profile, we merge them.
We give these coverage profiles to DESeq2, and compute the p-values.
We thus have a p-value for each position of the genome.
We then use a very crude hidden Markov model (HMM) on each chromosome of the genome.
The HMM has two states: "not differentially expressed", and "differentially expressed".
Each state uses a binomial distribution, the probability to emit a p-value < 0.5, and the probability to emit a p-value >= 0.5.
We did not try to optimize the parameters of the HMM, because it takes times, and do not improve the results.
Instead, the HMM is used a crude (but effective) way to segment the genome.

The parameters of the HMM can be changed using these functions:

    exp <- setTransitionProbabilities(exp, prob1, prob2)
    exp <- setEmissionProbabilities(exp, prob3)

where:

 * `prob1` is the probability to move from the "not differentially expressed" state to the "differentially expressed" state,
 * `prob2` is the probability to move from the "differentially expressed" state to the "not differentially expressed" state,
 * `prob3` is the probability to emit a p-value < 0.5 in the "differentially expressed" state, and a p-value >= 0.5 in the "not differentially expressed" state.

This method is efficient when a region is highly differentially expressed, even if it is concealed in a longer transcript.


### Slicing

This stretegy proceeds in three steps:

 * It normalizes counts using a CPM strategy developped in EdgeR.
 * The mean distribution of the coverage of the replicates is computed for each condition.
 * For each condition, we "slice" the mean coverage distribution: we add horizontal lines at height h (where h is the minimum depth parameter defined in the general parameter section), h+1, h+2, ..., + infinity, and the intervals where the distribution and the horizontal lines meet is a putative region.
 * These putative regions are the output of the strategy.

Obviously, many putative regions may have very similar start and end points.  If two regions differ only by a few base pairs, the smallest regions will be discarded.

The default values can be changed using these functions:

    exp <- setMinDifferences(exp, numeric)

This method is especially efficient when a differentially expressed region is large, even though the fold change is moderate.


### General parameters

The three last strategies can be tuned by specifying:

 * the minimum and maximum regions sizes,
 * the minimum depth of the most expressed condition.

The default values can be changed using these functions:

    exp <- setMinDepth(exp, numeric)
    exp <- setSizes(exp, minSize, maxSize)


### Combination of the strategies

All the regions given by each strategies are then combined into a list of
regions.
DESeq2 is then used to get the adjusted p-values of these regions.

You can choose not to use some strategies, use the function

    exp <- useStrategies(annotation, naive, HMM, slice)

where `annotation`, `naive`, `HMM` and `slice` are logical variables, set to `FALSE` if you want to skip that step.


### Extracting regions

The regions, with corresponding information provided by DESeq2 (mean expression, fold-change, p-value, adjusted p-value, etc.), can be extracted with this command:

    regions <- regions(exp, pValue)

where `pValue` is the (adjusted) p-value threshold.  The output in a `GenomicIntervals` object, and the information is accessible with the `mcols()` function.


## Visualization

You can get the read coverage profile of your selected regions using the
`plotRegion` method.  For instance, if `exp` is your `srnadiff` object, you
can type:

    plotRegion(exp, regions(exp, 0.05)[1])

Each line provides the read density on an input sample.
The dark grey rectangle emphasizes the selected region.


## Misc

### Naming the conditions

The conditions can be sorted (`WT` before `mutant`, `untreated` before
`treated`) this way:

    conditions  <- factor(c("wt", "wt", "ko", "ko"), levels=c("wt", "ko"))


### Using several cores

The quantification and differential expression steps can be accelerated using
several cores and the following command:

    exp <- setNThreads(exp, nThreads)


### Troubleshooting

While installing the package, if the compiler complains and says

    #error This file requires compiler and library support for the ISO C++ 2011 standard.
    This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.

Add this line

    Sys.setenv("PKG_CXXFLAGS"="-std=c++11")

before installing the package.
