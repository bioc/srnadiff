---
title: "The sRNADiff package"
author: "Matthias Zytnicki"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

sRNADiff aims at finding differentially expressed short RNAs with or without
annotation.  To do so, sRNADiff uses up to 4 different strategies:

- annotation-based,
- naive,
- HMM,
- clustering.

## Standard workflow

    annotation  <- readMiRBasePreAnnotation("mirbase.gff")
    bamFiles    <- c("wt1.bam", "wt2.bam", "ko1.bam", "ko2.bam")
    replicates  <- c("wt1", "wt2", "ko1", "ko2")
    conditions  <- factor(c("wt", "wt", "ko", "ko"))
    exp         <- sRNADiffExp(annotation, bamFiles, replicates, conditions)
    diffRegions <- runAll(exp)
    
    
## Example

Raw data have been downloaded from the GEO data set
[GSE62830](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE62830),
provided in
[Viollet *et al.*, 2015](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0126439).
Adapters were removed with
[fastx_clipper](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html)
and mapped with
[bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml)
on the human genome version GRCh38.

This example provides this data, restricted to a small locus on chr14.
It uses the whole genome annotation (with coding genes, etc.)
and extracts miRNAs.

    dir         <- system.file("extdata", package="srnadiff", mustWork = TRUE)
    data        <- read.csv(file.path(dir, "data.csv"))
    gtfFile     <- file.path(dir, "Homo_sapiens.GRCh38.76.gtf")
    annotation  <- readWholeGenomeAnnotation(gtfFile)
    bamFiles    <- file.path(dir, data$FileName)
    replicates  <- data$SampleName
    conditions  <- factor(data$Condition)
    exp         <- sRNADiffExp(annotation, bamFiles, replicates, conditions)
    diffRegions <- runAll(exp)


## Rationale and scope of the package

There is no real method for finding differentially expressed short RNAs.  The
most used method focusses on miRNAs, and only uses a standard RNA-Seq pipe-line
on these genes.

However, annotated tRF, siRNAs, piRNA, etc. are thus out of the scope of these
analyses.  Several ad hoc method have been used, and this package implements a
unifying method, finding differentially expressed genes or regions of any kind.


## Explanation of the different strategies

Each strategy segments the genome its own way and finds potential differentially
expressed regions.
Every strategy makes assumption of the profiles of the differentially expressed
regions.
These assumptions differ between strategies, and thus it is useful to combined
them.

### Annotation

This is the standard pipe-line, and the method simply provides the list of miRNA
genes extracted from the given GTF file.

If you do not provide a GTF file, this step is skipped.  Alternatively, you can
type `exp@skipAnnotation <- TRUE` for the same result.

Unfortunately, there is no clear standard for an annotation format.
We provide here four ways to parse the annotation file.

#### Whole genome file annotation

This GTF file can be found in the central repositories (NCBI, Ensembl) and
contains all the annotation found in an organism (coding genes, tranposable
element, etc.).
The following function reads the annotation file and extracts the miRNAs.

    annotation <- readWholeGenomeAnnotation(filename)

#### miRBase annotation

miRBase is the central repository for miRNAs.
The following function parses a GFF3 miRBase file, and extracts the precursor
miRNAs.

    annotation <- readMiRBasePreAnnotation(filename)

As a result, the reads will be counted per pre-miRNA, and the 5' and 3' arms,
the miRNA and the miRNA* will be merged in the same feature.
If you want to separate the two, use:

    annotation <- readMiRBaseMatureAnnotation(filename)

#### Other format

When the previous functions do not work, you can use your own parser with:

    annotation <- readAnnotation(filename, source, feature, name)

The `source` parameter keeps all the lines such that the second field matches
the given parameter (e.g. `miRNA`).
The `feature` parameter keeps all the lines such that the third field matches
the given parameter (e.g. `gene`).
The name of the feature will be given by the tag `name` (e.g. `gene_name`).
`source`, `feature` and `name` can be `NULL`.
In this case, no selection is performed on `source` or `feature`.
If `name` is null, then a systematic name is given (`annotation_N`).



### Naive

The method first merges all the BAM files.  Reads are then merged into regions:
if two reads overlap, they will belong to the same regions.  Regions with at
least 10 reads (summing all the reads in all input BAM files) are kept.

This method is efficient when a gene is differentially expressed on the whole
transcript.

Type `exp@skipNaive <- TRUE` if you want to skip this step.


### HMM

We first compute the coverage of every input BAM file of every nucleotide of the
genome.
If two genome nucleotides have exactly the same coverage profile, we merge them.
We give these coverage profiles to DESeq2, and compute the p-values.
We thus have a p-value for each position of the genome.
We then use a very crude hidden Markov model (HMM) on each chromosome of the
genome.
The HMM has two states: non-differentially expressed, and differentially
expressed.
Each state uses a binomial distribution.
We did not try to optimize the parameters of the HMM, because it takes times,
and do not improve the results.
Instead, the HMM is used a crude (but effective) way to segment the genome.

This method is efficient when a region is highly differentially expressed, even
if it is concealed in a longer transcript.

Type `exp@skipHmm <- TRUE` if you want to skip this step.

### Combination of the strategies

All the regions given by each strategies are then combined into a list of
regions.
DESeq2 is then used to get the adjusted p-values of these regions.
All the regions with p-value less than 5% are then given.
This threshold can by modified typing e.g. `exp@pValue <- 0.01`.


## Misc

### Naming the conditions

The conditions can be sorted (`WT` before `mutant`, `untreated` before
`treated`) this way:

    conditions  <- factor(c("wt", "wt", "ko", "ko"), levels=c("wt", "ko"))


### Using several cores

The quantification and differential expression steps can be accelerated using
several cores and the
[BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html)
package and the following command:

    library("BiocParallel")
    register(MulticoreParam(4))
